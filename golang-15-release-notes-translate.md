# Go 1.5介绍

最新发布的go 1.5版本是意义重大的一个版本，从主要架构到语言实现都有很大的改进。尽管如此我们依然遵守之前兼容性约定，承诺以前的go程序在这个版本都可以像以前一样编译和运行。

本版本最大的更新点如下

* 编译器和运行时现在均采用go语言开发（含少量汇编），成功实现自举。go 1.5中已经完全没有C实现，编译go语言环境也不再需要C编译器。
* 新的垃圾回收器现在是并发执行了，在可能的情况会和其他goroutine并行执行，因为垃圾回收而产生的系统暂停事件大大缩短。
* GOMAXPROCS默认设置为当前机器的cpu数目，之前默认为1
* 不仅GO核心，所有代码库现在都支持internel packages
* go命令现在实验性地支持"vendor"外部依赖。
* 新增go tool trace命令，可以很细粒度的追踪程序的执行情况。
* 新增go doc(注意空格，不是godoc)命令为命令行使用场景定制

另外还有针对语言实现和工具的修改，将在下面讨论。

本版本还包含语法层面针对map字面值的一点修改。

最后，这次版本发布周期比之前的6各月要长，主要原因是为了本次更新提供更多时间，以及为下个版本的发布时间节省时间。

## 语言层面的变化

### map字面量

由于之前的疏忽，对于元素类型是slice的初始化不允许省略slice类型名，1.5版本中更正了这个问题。比如以下map字面量

``` go
m := map[Point]string{
    Point{29.935523, 52.891566}:   "Persepolis",
    Point{-25.352594, 131.034361}: "Uluru",
    Point{37.422455, -122.084306}: "Googleplex",
}
```

可以用下面的方法初始化：

``` go
m := map[Point]string{
    {29.935523, 52.891566}:   "Persepolis",
    {-25.352594, 131.034361}: "Uluru",
    {37.422455, -122.084306}: "Googleplex",
}
```
## 实现

### 不再使用c

编译器和运行时现在都使用Go和汇编实现，没有C了。源代码中唯一的C代码仅在测试和cgo中存在。在1.4版本及以前，编译运行时库时还存在一个C编译器；为了保证C代码能够和goroutine堆栈管理相关的代码一起工作，我们不得不保留一个定制的C编译器。由于现在runtime已经全部采用Go实现，现在已经不需要这个C编译器了，所以在Go源代码中它也被删除了。

我们为了将C代码修改过来开发了定制的代码转换工具，将C语言代码转换为Go代码并最终移除了C编译器。实际上效果程序还是同一个，但是编写语言不同，因此我们认为这应该不会引入新的编译错误。

### 编译器及工具

由于以前全部迁移到Go实现，部分工具的名字也改了。曾经的6g,8g等等没有了，只留下了一个二进制程序，通过go tool compile执行，将根据$GOARCH和$GOOS把源代码编译为二进制文件。同样，现在也只有一个链接程序(go tool link)和一个汇编器(go tool asm).

### 垃圾回收器

1.5版本的垃圾回收期被重新设计和实现，可参考此[设计文档](https://golang.org/s/go14gc)。相对对此前的版本，通过算法改进、回收期调度改进、并行回收等方法，垃圾回收的等待时间大幅缩短。垃圾回收启动时的系统暂停时间将永远控制在10ms以内！

对于相应时间敏感的系统如web网站，这个改进带来的意义重大。

详情可参考2015 GoConf上的[这个分享](https://talks.golang.org/2015/go-gc.pdf)。

### 运行时

在Go1.5中，goroutine的调度顺序有所调整。尽管调度器的行为属性在语言层面并未定义相关语法，但是依赖调度器调度顺序的程序可能会出问题。我们已经发现一小部分程序被这个改动影响了(⊙o⊙)…如果你有依赖调度器调度顺序的程序，你可能需要修改他们了。

另一个很大的变化是，默认的线程数量（GOMAXPROCS）从以前的1修改为当前的CPU数目。如果程序不希望在多核运行，必须显示设置GOMAXPROCS为1.具体可以参考这篇[设计文档](https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit)。



未完待续...